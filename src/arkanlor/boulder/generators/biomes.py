"""
    Biomes.
    
    generated by a noise for 8x8 you can have biomes controlling the macro
    layout of your world.
"""
import numpy

def select_tile(tile_list, f):
    # selects a tile from tile_list.
    l = len(tile_list) # total number of tiles.
    if f >= 1.0:
        f = 0.99
    return tile_list[ int(numpy.floor(l * f)) ]

class UOTiles:
    water = [0xa8 + x for x in xrange(4)]
    water_shallow = [0x136, 0x137]
    grass = [0x3 + x for x in xrange(3)]
    rock = [0xda + x for x in xrange(3)]
    sand = [0x16 + x for x in xrange(4)]

class Biome(object):
    """
        a biome represents, how this area is populated.
    """
    def apply_cell(self, mapblock, rx, ry, hf, tf):
        mapblock.tiles[rx, ry] = 0x0
        mapblock.heights[rx, ry] = 0

    def apply(self, mapblock, height_map, tile_map):
        for rx in xrange(8):
            for ry in xrange(8):
                hf = height_map[rx, ry]
                if tile_map is not None:
                    # a tile map is optional
                    tf = tile_map[rx, ry]
                else:
                    tf = 0.0
                # normally we should do something with this information.
                # however, for benchmarking we just touch all variables.
                # we set ourselves to None.
                self.apply_cell(mapblock, rx, ry, hf, tf)


class DeepSea(Biome):
    def apply_cell(self, mapblock, rx, ry, hf, tf):
        if hf < 0.9:
            # water normal.
            mapblock.tiles[rx, ry] = select_tile(UOTiles.water, tf)
        else:
            mapblock.tiles[rx, ry] = select_tile(UOTiles.water_shallow, tf)
        mapblock.heights[rx, ry] = 0

class Coastal(Biome):
    def apply_cell(self, mapblock, rx, ry, hf, tf):
        if hf < 0.1:
            # water normal.
            mapblock.tiles[rx, ry] = select_tile(UOTiles.water, tf)
            mapblock.heights[rx, ry] = 0
        elif hf < 0.5:
            # sandcoast
            mapblock.tiles[rx, ry] = select_tile(UOTiles.sand, tf)
            mapblock.heights[rx, ry] = int(hf * 8)
        else:
            # grass or dirt or smth
            mapblock.tiles[rx, ry] = select_tile(UOTiles.grass, tf)
            mapblock.heights[rx, ry] = int(hf * 8)

class GrassLand(Biome):
    def apply_cell(self, mapblock, rx, ry, hf, tf):
        # grass or dirt or smth
        mapblock.tiles[rx, ry] = select_tile(UOTiles.grass, tf)
        mapblock.heights[rx, ry] = int(hf * 8)


# used to scatter biomes themselves.
default_biomes = [
        # range, biomeclass
        (0.0, 0.1, DeepSea()),
        (0.1, 0.3, Coastal()),
        (0.3, 1.1, GrassLand()),
          ]

def get_biome(f, biomes=default_biomes):
    for biome in biomes:
        lo, hi, b = biome
        if f >= lo and (f < hi):
            return b
    return Biome()

