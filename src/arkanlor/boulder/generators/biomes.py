"""
    Biomes.
    
    generated by a noise for 8x8 you can have biomes controlling the macro
    layout of your world.
"""
import numpy
from arkanlor.misc.geology import Voronoi, MidpointDisplacementNoise
from arkanlor.boulder.generators.const import UOTiles

def select_tile(tile_list, f):
    # selects a tile from tile_list.
    l = len(tile_list) # total number of tiles.
    if not l:
        return 0x1
    if f >= 1.0:
        f = 0.99
    return tile_list[ int(numpy.floor(l * f)) ]

class Biome(object):
    """
        a biome represents, how this area 8x8 is populated.
    """
    def __init__(self, height=None):
        self.height = height or 0
    def apply_cell(self, mapblock, rx, ry, hf, tf):
        mapblock.tiles[rx, ry] = 0x0
        mapblock.heights[rx, ry] = 0

    def apply(self, mapblock, height_map=None, tile_map=None):
        if height_map is None:
            height_map = mapblock.height_map
        if tile_map is None:
            tile_map = mapblock.tile_map
        for rx in xrange(8):
            for ry in xrange(8):
                hf = height_map[rx, ry]
                if tile_map is not None:
                    # a tile map is optional
                    tf = tile_map[rx, ry]
                else:
                    tf = 0.0
                # normally we should do something with this information.
                # however, for benchmarking we just touch all variables.
                # we set ourselves to None.
                self.apply_cell(mapblock, rx, ry, hf, tf)

class Blackness(Biome):
    def apply_cell(self, mapblock, rx, ry, hf, tf):
        mapblock.tiles[rx, ry] = 0x244 # noname blackness.
        mapblock.heights[rx, ry] = 0

class DeepSea(Biome):
    def apply_cell(self, mapblock, rx, ry, hf, tf):
        if hf < 0.1:
            mapblock.tiles[rx, ry] = select_tile(UOTiles.water_deep, tf)
            mapblock.heights[rx, ry] = self.height
        else:
            # water normal.
            mapblock.tiles[rx, ry] = select_tile(UOTiles.water, tf)
            mapblock.heights[rx, ry] = self.height

class ShallowSea(Biome):
    def apply_cell(self, mapblock, rx, ry, hf, tf):
        if hf < 0.1:
            mapblock.tiles[rx, ry] = select_tile(UOTiles.water_deep, tf)
            mapblock.heights[rx, ry] = self.height
        elif hf < 0.94:
            # water normal.
            mapblock.tiles[rx, ry] = select_tile(UOTiles.water, tf)
            mapblock.heights[rx, ry] = self.height
        else:
            mapblock.tiles[rx, ry] = select_tile(UOTiles.sand, tf)
            mapblock.heights[rx, ry] = self.height + int(hf * 2)

class Coastal(Biome):
    def apply_cell(self, mapblock, rx, ry, hf, tf):
        if hf < 0.2:
            # water normal.
            mapblock.tiles[rx, ry] = select_tile(UOTiles.water, tf)
            mapblock.heights[rx, ry] = self.height
        elif hf < 0.4:
            # sandcoast
            mapblock.tiles[rx, ry] = select_tile(UOTiles.sand, tf)
            mapblock.heights[rx, ry] = self.height + int(hf * 8)
        else:
            # grass or dirt or smth
            mapblock.tiles[rx, ry] = select_tile(UOTiles.grass, tf)
            mapblock.heights[rx, ry] = self.height + int(hf * 8)

class GrassLand(Biome):
    def apply_cell(self, mapblock, rx, ry, hf, tf):
        # grass or dirt or smth
        mapblock.tiles[rx, ry] = select_tile(UOTiles.grass, tf)
        mapblock.heights[rx, ry] = self.height + int(hf * 8)

class MurkyGrassLand(Biome):
    def apply_cell(self, mapblock, rx, ry, hf, tf):
        # grass or dirt or smth
        if hf < 0.4:
            mapblock.tiles[rx, ry] = select_tile(UOTiles.grass_murky, tf)
            mapblock.heights[rx, ry] = self.height + int(hf * 8)
        else:
            mapblock.tiles[rx, ry] = select_tile(UOTiles.grass, tf)
            mapblock.heights[rx, ry] = self.height + int(hf * 8)

class Rocks(Biome):
    def apply_cell(self, mapblock, rx, ry, hf, tf):
        if hf < 0.05:
            mapblock.tiles[rx, ry] = select_tile(UOTiles.grass, tf)
            mapblock.heights[rx, ry] = self.height + int(hf * 8)
        elif hf < 0.25:
            # dirt
            mapblock.tiles[rx, ry] = select_tile(UOTiles.dirt, tf)
            mapblock.heights[rx, ry] = self.height + int(hf * 8)
        elif hf < 0.4:
            # rocksides
            mapblock.tiles[rx, ry] = select_tile(UOTiles.dirt_stones, tf)
            mapblock.heights[rx, ry] = self.height + int(hf * 8) + 2
        else:
            mapblock.tiles[rx, ry] = select_tile(UOTiles.rock, tf)
            mapblock.heights[rx, ry] = self.height + int(hf * 16) + 6

class HighLands(Biome):
    def apply_cell(self, mapblock, rx, ry, hf, tf):
        if hf < 0.15:
            # dirt
            mapblock.tiles[rx, ry] = select_tile(UOTiles.dirt, tf)
            mapblock.heights[rx, ry] = self.height + int(hf * 8) + 5
        elif hf < 0.3:
            # rocksides
            mapblock.tiles[rx, ry] = select_tile(UOTiles.dirt_stones, tf)
            mapblock.heights[rx, ry] = self.height + int(hf * 8) + 6
        else:
            mapblock.tiles[rx, ry] = select_tile(UOTiles.rock, tf)
            mapblock.heights[rx, ry] = self.height + int(hf * 16) + 12

class Mountains(Biome):
    def apply_cell(self, mapblock, rx, ry, hf, tf):
        if hf < 0.5:
            mapblock.tiles[rx, ry] = select_tile(UOTiles.rock, tf)
            mapblock.heights[rx, ry] = self.height + int(hf * 16) + 12
        else:
            mapblock.tiles[rx, ry] = select_tile(UOTiles.snow, tf)
            mapblock.heights[rx, ry] = self.height + int(hf * 16) + 13


# used to scatter biomes themselves.
default_biomes = [
        # range, biomeclass
        (0.0, 0.1, DeepSea()),
        (0.1, 0.25, Coastal()),
        (0.25, 0.7, GrassLand()),
        (0.7, 1.1, Rocks()),
          ]

def get_biome_by_range(f, biomes=default_biomes):
    for biome in biomes:
        lo, hi, b = biome
        if f >= lo and (f < hi):
            return b
    return Biome()

